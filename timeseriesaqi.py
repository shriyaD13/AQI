# -*- coding: utf-8 -*-
"""TimeSeriesAQI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hu36rd3QKi6tWpyEgYE8J7oDiEPJmtoR

#Importing necessary libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# Import libraries 
import numpy as np 
import pandas as pd

import seaborn as sns
# %matplotlib inline
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import datetime as dt
from datetime import datetime
from datetime import timedelta

import matplotlib.pyplot as plt
plt.style.use('ggplot')
plt.rcParams["figure.figsize"] = [16,9]

"""# Loading data"""

df = pd.read_csv("/content/city_day.csv",parse_dates = ['Date'], index_col = ['Date'])

data=df[df['City']=='Delhi']
data

df2 = data['AQI']
df2

"""# Repalcing null values"""

print(df2.isnull().sum())

#Replacing the missing values with the mean
def impute_mean(series):
    return series.fillna(series.mean())

df2= df2.transform(impute_mean)

print(df2.isnull().sum())

"""# Visualizing the data"""

plt.xlabel('Date')
plt.ylabel('AQI')
plt.plot(df2)

rolling_mean = df2.rolling(window = 12).mean()
rolling_std = df2.rolling(window = 12).std()
plt.plot(df2, color = 'blue', label = 'Original')
plt.plot(rolling_mean, color = 'red', label = 'Rolling Mean')
plt.plot(rolling_std, color = 'black', label = 'Rolling Std')
plt.legend(loc = 'best')
plt.title('Rolling Mean & Rolling Standard Deviation')
plt.show()

from statsmodels.tsa.stattools import adfuller

result = adfuller(df2)
print('ADF Statistic: {}'.format(result[0]))
print('p-value: {}'.format(result[1]))
print('Critical Values:')
for key, value in result[4].items():
    print('\t{}: {}'.format(key, value))

df_log = np.log(df2)
plt.plot(df_log)

"""# Arima"""

def get_stationarity(timeseries):
    
    # rolling statistics
    rolling_mean = timeseries.rolling(window=12).mean()
    rolling_std = timeseries.rolling(window=12).std()
    
    # rolling statistics plot
    original = plt.plot(timeseries, color='blue', label='Original')
    mean = plt.plot(rolling_mean, color='red', label='Rolling Mean')
    std = plt.plot(rolling_std, color='black', label='Rolling Std')
    plt.legend(loc='best')
    plt.title('Rolling Mean & Standard Deviation')
    plt.show(block=False)
    
    # Dickeyâ€“Fuller test:
    result = adfuller(timeseries)
    print('ADF Statistic: {}'.format(result[0]))
    print('p-value: {}'.format(result[1]))
    print('Critical Values:')
    for key, value in result[4].items():
        print('\t{}: {}'.format(key, value))

rolling_mean = df_log.rolling(window=12).mean()
df_log_minus_mean = df_log - rolling_mean
df_log_minus_mean.dropna(inplace=True)
get_stationarity(df_log_minus_mean)

rolling_mean_exp_decay = df_log.ewm(halflife=12, min_periods=0, adjust=True).mean()
df_log_exp_decay = df_log - rolling_mean_exp_decay
df_log_exp_decay.dropna(inplace=True)
get_stationarity(df_log_exp_decay)

df_log_shift = df_log - df_log.shift()
df_log_shift.dropna(inplace=True)
get_stationarity(df_log_shift)

"""## AQI prediction"""

from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima_model import ARIMA

decomposition = seasonal_decompose(df_log) 
model = ARIMA(df_log, order=(2,1,2))
results = model.fit(disp=-1)
plt.plot(df_log_shift, color='green')
plt.plot(results.fittedvalues)

predictions = results.predict(start=datetime(2020,7,1),end=datetime(2020,7,30),typ="levels")
predictions_inv = np.exp(predictions)
predictions_inv

data_2020 = df2[df2.index >= "2020-6-30"] 
plt.plot(data_2020)
plt.plot(predictions_inv,"g")
plt.title("AQI predicted for 2020/07")

"""## SO2 prediction"""

df_so2 = data["SO2"]

print(df_so2.isnull().sum())

df_so2= df_so2.transform(impute_mean)
print(df_so2.isnull().sum())

dfSo2_log = np.log(df_so2)
plt.plot(dfSo2_log)

get_stationarity(dfSo2_log)

dfSo2_log_shift = dfSo2_log - dfSo2_log.shift()
dfSo2_log_shift.dropna(inplace=True)
get_stationarity(dfSo2_log_shift)

decomposition = seasonal_decompose(dfSo2_log) 
model2 = ARIMA(dfSo2_log, order=(2,1,2))
results2 = model2.fit(disp=-1)
plt.plot(dfSo2_log_shift, color='green')
plt.plot(results2.fittedvalues)

predictions2 = results2.predict(start=datetime(2020,7,1),end=datetime(2020,7,30),typ="levels")
predictions2_inv = np.exp(predictions2)
predictions2_inv

dataSO2_2020 = df_so2[df_so2.index >= "2020-6-25"] 
plt.plot(dataSO2_2020)
plt.plot(predictions2_inv,"g")
plt.title("SO2 predicted for 2020/07")

"""## NO2 prediction"""

df_no2 = data["NO2"]

df_no2= df_no2.transform(impute_mean)
print(df_no2.isnull().sum())

dfNo2_log = np.log(df_no2)
plt.plot(dfNo2_log)

dfNo2_log_shift = dfNo2_log - dfNo2_log.shift()
dfNo2_log_shift.dropna(inplace=True)
get_stationarity(dfNo2_log_shift)

decomposition = seasonal_decompose(dfNo2_log) 
model3 = ARIMA(dfNo2_log, order=(2,1,2))
results3 = model3.fit(disp=-1)
plt.plot(dfNo2_log_shift, color='green')
plt.plot(results3.fittedvalues)

predictions_no2 = results3.predict(start=datetime(2020,7,1),end=datetime(2020,7,30),typ="levels")
predictions3_inv = np.exp(predictions_no2)
predictions3_inv

datano2_2020 = df_no2[df_no2.index >= "2020-6-25"] 
plt.plot(datano2_2020)
plt.plot(predictions3_inv,"g")
plt.title("NO2 predicted for 2020/07")

"""## CO prediction"""

df_co = data["CO"]

df_co= df_co.transform(impute_mean)
print(df_co.isnull().sum())

model4 = ARIMA(df_co, order=(2,1,2))
results4 = model4.fit(disp=-1)

predictions_Co = results4.predict(start=datetime(2020,7,1),end=datetime(2020,7,30),typ="levels")
predictions_Co

dataco_2020 = df_co[df_co.index >= "2020-6-25"] 
plt.plot(dataco_2020)
plt.plot(predictions_Co,"g")
plt.title("CO predicted for 2020/07")

"""## Final values"""

finalAQI_predicted = predictions_inv
finalSO2_predicted = predictions2_inv
finalNO2_predicted= predictions3_inv
finalCO_predicted = predictions_Co

"""# Sarima"""

df2.values

import statsmodels.api as sm

# define model configuration
my_order = (0, 0, 0)
my_seasonal_order = (1, 0, 1, 12)
# define model
smodel = sm.tsa.SARIMAX(df2, order=my_order,seasonal_order=my_seasonal_order,trend= 't')

result_seasonal = smodel.fit()

print(result_seasonal.summary())

predictions_seasonal = result_seasonal.predict(start=datetime(2020,7,1),end=datetime(2020,8,30),typ="levels")
predictions_seasonal

dataS_2020 = df2[df2.index >= "2020-6-10"] 
plt.plot(dataS_2020)
plt.plot(predictions_seasonal,"g")
plt.title("AQI predicted for 2020/07 using SARIMA")

"""## Pacf and acf """

get_stationarity(df3)

df3_log= df3.apply(lambda x: np.log(x))  
get_stationarity(df3_log)

df3_first_diff = df3 - df3.shift(1)  
get_stationarity(df3_first_diff.dropna(inplace=False))

df_seasonal_diff = df3 - df3.shift(12)  
get_stationarity(df_seasonal_diff.dropna(inplace=False))

df3_log_seasonal_Diff = df3_log - df3_log.shift(12)  
get_stationarity(df3_log_seasonal_Diff.dropna(inplace=False))

df3_seasonal_firstDIff = df3_first_diff - df3_first_diff.shift(12)  
get_stationarity(df3_seasonal_firstDIff.dropna(inplace=False))

fig = plt.figure(figsize=(12,8))
ax1 = fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(df3_seasonal_firstDIff.iloc[13:], lags=40, ax=ax1)
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(df3_seasonal_firstDIff.iloc[13:], lags=40, ax=ax2)

"""## Predicting on newData"""

new_data= pd.read_csv("/content/new_data.csv",parse_dates = ['Date'], index_col = ['Date'])

new_data

df3 = new_data["AQI"]
df3

plt.xlabel('Date')
plt.ylabel('AQI')
plt.plot(df3)

smodel2 = sm.tsa.SARIMAX(df3, order=my_order,seasonal_order=my_seasonal_order,trend= 't')

result2 = smodel2.fit()

pred_today = result2.predict(datetime(2021,3,16),type="levels")
pred_today

predictions_seasonal2 = result2.predict(start=datetime(2021,3,17),end=datetime(2021,4,30),typ="levels")
predictions_seasonal2

data_new = df3[df3.index >= "2021-03-01"] 
plt.plot(data_new)
plt.plot(predictions_seasonal2,"g")
plt.title("AQI predicted for March-April 2021 using SARIMA")

df3_So2 = new_data["SO2"]
smodel_So2 = sm.tsa.SARIMAX(df3_So2, order=my_order,seasonal_order=my_seasonal_order,trend= 't')
result_So2 = smodel_So2.fit()
predictions_SO2 = result_So2.predict(start=datetime(2021,3,17),end=datetime(2021,4,30),typ="levels")
predictions_SO2

df3_No2 = new_data["NO2"]
smodel_No2 = sm.tsa.SARIMAX(df3_No2, order=my_order,seasonal_order=my_seasonal_order,trend= 't')
result_No2 = smodel_No2.fit()
predictions_No2 = result_No2.predict(start=datetime(2021,3,17),end=datetime(2021,4,30),typ="levels")
predictions_No2

df3_PM10 = new_data["PM10"]
smodel_PM10 = sm.tsa.SARIMAX(df3_PM10, order=my_order,seasonal_order=my_seasonal_order,trend= 't')
result_PM10 = smodel_PM10.fit()
predictions_PM10 = result_PM10.predict(start=datetime(2021,3,17),end=datetime(2021,4,30),typ="levels")
predictions_PM10

